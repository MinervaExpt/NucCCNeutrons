#Sketch of a YAML file with a tree of cuts whose end points are each a Study.
#Begin keywords
#Global configuration parameters like which neutron candidate reconstruction
#method to use.
app:

#A Study makes plots from an event after it's gotten to the
#bottom of some chain of Cuts.  So, every leaf of the Cut
#trees defined in RecoCuts and TruthCuts below gets a Study
#of this type.
study: !NeutronMultiplicity
#There could be configuration parameters here that NeutronMultiplicity
#reads.

#Cuts I'm going to apply
#Kinematic and quality cuts inherited from the MEC analysis.
MECMuonKinematics: &MECMuonKinematics !MuonKinematics
  MaxMuonAngle: 20 #degrees
  MinMuonMomentum: 1500 #MeV
  MinNeutrinoE: 2000 #MeV

MECMinosMatch: &MECMinosMatch !MinosTime
  MinTime: -40 #ns
  MaxTime: 110 #ns

Antineutrino: &Antineutrino !Helicity
  Helicity: 2 #antineutrino via a MINERvA framework typedef

#Categorize neutron candidates by what FS particle produced them
GENIENeutrons: &GENIENeutrons !FSPDGCodes
  PDGs: [2112]

GeantNeutrons: &GeantNeutrons !IsNeutronFromGeant

EMAndHadrons: &EMAndHadrons !FSPDGCodes
  PDGs: [211, -211, 2212, 111, -111, 311, -311, 22]

Muon: &Muon !FSPDGCodes
  PDGs: [13, -13]

#MEC analysis q3 binning
LowQ3: &LowQ3 !NucCCNeutrons_q3 #TODO: A preprocessor macro to automatically write the Cut boilerplate
                         #      code for any AnaTuple branch.  I just have to create a file that
                         #      calls the macro.
  max: 0.4
  GENIENeutrons: *GENIENeutrons
  GeantNeutrons: *GeantNeutrons
  EMAndHadrons: *EMAndHadrons
  Muon: *Muon
  Other:

MidQ3: &MidQ3 !NucCCNeutrons_q3
  max: 0.8
  GENIENeutrons: *GENIENeutrons
  GeantNeutrons: *GeantNeutrons
  EMAndHadrons: *EMAndHadrons
  Muon: *Muon
  Other:

HighQ3: &HighQ3
  GENIENeutrons: *GENIENeutrons
  GeantNeutrons: *GeantNeutrons
  EMAndHadrons: *EMAndHadrons
  Muon: *Muon
  Other:

#TODO: This seems substantially less evil than the other approaches.
#      I'm planning to implement it.  Run it past someone else first
#      and see how confused they are.

#Another approach to reduce reliance on hierarchies: AND and OR objects.
#Now I've got an extra hierarchy level to specify whether each level is
#an AND or an OR.
MECCuts: &MECCuts !AND
  Antineutrino: *Antineutrino
  MECMuonKinematics: *MECMuonKinematics
  MECMinosMatch: *MECMinosMatch

Q3Categories: &Q3Categories !OR
  LowQ3: !Q3Cut
    max: 0.4
  MidQ3: !Q3Cut
    max: 0.8
  HighQ3: !Other #An Other Cut always returns true.  Think of an overflow bin.

OneTrackCuts: &OneTrackCuts !OR
  Target1: !AND
    Fiducial: !Target
      zMin: 
      zMax:
    DistanceToDivision: !DistanceToDivision
      distance: 25 #mm  From NukeCCInclusive
    Material: !OR
      Iron: !TwoSection #TODO: Is this the "top" or the "bottom" section?  I'd feel a lot better if that was
                        #      set in c++ rather than a configuration file.  I never expect to change the
                        #      angle of the division between iron and lead.  The power to only process all iron
                        #      sections might still be powerful though.
                        #Realized that I won't need to write angle here at all if I go with my recommendations to
                        #data preservation: It will be done for me in the Gaudi stage!  There will still be some
                        #combinatorics here that would benefit from knowing that this is target 1.
        angle: 60
      Lead: !TwoSection
        angle: 60
  Target2: !AND
    Fiducial: !Target
      zMin:
      zMax:
    DistanceToDivision: !DistanceToDivision
      distance: 25 #mm  From NukeCCInclusive
    Material: !OR
      Iron: !TwoSection
        angle: -60
      Lead: !TwoSection
        angle: -60
  Target3: !AND
    Fiducial: !Target
      zMin:
      zMax:
    DistanceToDivision: !DistanceToDivision
      distance: 25 #mm  From NukeCCInclusive
    Material: !OR
      Iron: !ThreeSection
      Lead: !ThreeSection
      Carbon: !ThreeSection
#TODO: Water, Target4, Target5, and Tracker

#TODO: Define MultiTrackCuts structure similar to OneTrackCuts above...

#Define the main analysis structure using the definitions above
RecoCuts: !AND
  MECCuts: *MECCuts
  Q3: *Q3Categories #TODO: Can I pick a category and continue like this without writing NumberOfTracks
                    #      for each q3 bin?  Yes!  The Q3 cut "returns true" if this event fits into
                    #      any category (it will in this case) and also returns the name of the cut
                    #      passed.  This lets me define Cut combinatorics with a flat structure.
                    #      The implementation seems a little tricky, but I can at worst pass around
                    #      a Directory& that gets modified by OR Cuts but not AND Cuts.
  NumberOfTracks: !OR
    OneTrack: !AND
      OnlyOneTrack: !NumberOfTracks
      Material: *OneTrackCuts
    MultiTrack: !AND
      Material: *MultiTrackCuts

#TruthCuts: !AND
  #TODO: Define truth-level cuts.  Only used if this file has a Truth tree.
  #      This Study has access to truth variables as well as whatever the
  #      reco study had.  So, it can make truth-matched plots.
  #
  #      I'll have some version of the kinematic cuts, DistanceToDivision, and
  #      Target limits here that uses the true vertex instead of the reco vertex.
  #TODO: How do things like sidebands fit into this application structure?  They
  #      could be defined by applying a combination of truth and reco cuts.  Can
  #      I define them automatically by the nature of the truth and reco variables
  #      I have?  Do I have to match truth cuts to reco cuts for this?

#Implementation notes for the author:
#TODO: Special AND and OR Cuts that set up other Cuts.
#TODO: A Study's plots inherit the names of all OR Cuts' children
#      they've passed.  AND Cuts are not categories.
#TODO: Maybe print out a cut table of only AND cuts when running on MC?
#TODO: A preprocessor macro to make cuts on AnaTuple variables
#      easy to define.  Ideal case would be just writing a header
#      with a description, include guards, an include for the macro,
#      and one line.
#TODO: BaseUnits integration with YAML-cpp?  Seems doable if I replace
#      the BaseUnits macros in NucCCNeutrons.  There's a wiki on the
#      yaml-cpp github page about how to add my own types.
